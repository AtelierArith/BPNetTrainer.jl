const NUM_MAX_FINGERPRINT_PARAMS = 4
const NENV_MAX = 2

"""
    FingerPrint

A structure representing molecular fingerprints for neural network training.

This struct contains all necessary information to define and compute molecular fingerprints
based on atomic environments. It supports various basis types (currently Chebyshev) and
stores parameters for radial and angular symmetry functions.

# Fields
- `itype::Int64`: Index of the atom type in the environment types list
- `description::String`: Human-readable description of the fingerprint
- `atomtype::String`: The atom type this fingerprint represents
- `nenv::Int64`: Number of environment types
- `envtypes::Vector{String}`: List of all environment atom types
- `rc_min::Float64`: Minimum cutoff radius
- `rc_max::Float64`: Maximum cutoff radius
- `sftype::String`: Symmetry function type (e.g., "Chebyshev")
- `nsf::Int64`: Number of symmetry functions
- `nsfparam::Int64`: Number of symmetry function parameters
- `sf::Vector{Int64}`: Symmetry function indices
- `sfparam::Matrix{Float64}`: Symmetry function parameters matrix
- `sfenv::Matrix{Int64}`: Environment mapping for symmetry functions
- `neval::Int64`: Number of evaluations performed
- `sfval_min::Vector{Float64}`: Minimum values for normalization
- `sfval_max::Vector{Float64}`: Maximum values for normalization
- `sfval_avg::Vector{Float64}`: Average values for normalization
- `sfval_cov::Vector{Float64}`: Covariance values for normalization

# See also
- [`FingerPrint(atomtype, envtypes; kwargs...)`](@ref): Constructor
- [`FingerPrintParams`](@ref): Parameter storage struct
"""
struct FingerPrint
    itype::Int64
    description::String
    atomtype::String
    nenv::Int64
    envtypes::Vector{String}
    rc_min::Float64
    rc_max::Float64
    sftype::String
    nsf::Int64
    nsfparam::Int64
    sf::Vector{Int64}
    sfparam::Matrix{Float64}
    sfenv::Matrix{Int64}
    neval::Int64
    sfval_min::Vector{Float64}
    sfval_max::Vector{Float64}
    sfval_avg::Vector{Float64}
    sfval_cov::Vector{Float64}
end

"""
    FingerPrint(atomtype, envtypes; kwargs...)

Construct a FingerPrint for a specific atom type and environment.

# Arguments
- `atomtype`: The target atom type (must be present in `envtypes`)
- `envtypes`: Vector of all possible atom types in the environment

# Keyword Arguments
- `basistype::String="Chebyshev"`: Type of basis functions to use
- `rc_min::Float64=0.55`: Minimum cutoff radius
- `rc_max::Float64=8.0`: Maximum cutoff radius (may be increased based on basis parameters)
- `description::String="generated by BPNET.jl"`: Description of the fingerprint

## Required for Chebyshev basis:
- `radial_Rc::Float64`: Radial cutoff radius
- `radial_N::Int`: Number of radial basis functions
- `angular_Rc::Float64`: Angular cutoff radius
- `angular_N::Int`: Number of angular basis functions

# Returns
- `FingerPrint`: Configured fingerprint structure

# Throws
- `AssertionError`: If `atomtype` is not found in `envtypes`
- `ErrorException`: If required kwargs are missing or unsupported basistype

# Example
```julia
envtypes = ["Ti", "O"]
fp = FingerPrint("Ti", envtypes, 
                radial_Rc=6.0, radial_N=10,
                angular_Rc=4.0, angular_N=5)
```
"""
function FingerPrint(
    atomtype,
    envtypes;
    basistype = "Chebyshev",
    rc_min = 0.55,
    rc_max = 8.0,
    description = "generated by BPNET.jl",
    kwargs...,
)
    itype = findfirst(x -> x == atomtype, envtypes)
    @assert typeof(itype) <: Integer "$(atomtype) is not found in $(envtypes)"
    nenv = length(envtypes)
    sftype = basistype
    if basistype == "Chebyshev"
        sfparam, sfenv, Rc, num_of_coeffs, num_of_parameters = chebyshevparam(nenv, kwargs)
        rc_max = max(Rc, rc_max)
    else
        error("basistype = $(basistype) is not supported")
    end
    sf = zeros(num_of_coeffs)
    sfval_min = zeros(num_of_coeffs)
    sfval_max = zeros(num_of_coeffs)
    sfval_avg = zeros(num_of_coeffs)
    sfval_cov = zeros(num_of_coeffs)
    neval = 0
    nsf = num_of_coeffs
    nsfparam = num_of_parameters

    return FingerPrint(
        itype,#::Int64
        description,#::String
        atomtype,#::String
        nenv,#::Int64
        envtypes,#::Vector{String}
        rc_min,#::Float64
        rc_max,#::Float64
        sftype,#::String
        nsf,#::Int64
        nsfparam,#::Int64
        sf,#::Vector{Int64}
        sfparam,#::Matrix{Float64}
        sfenv,#::Matrix{Int64}
        neval,#::Int64
        sfval_min,#::Vector{Float64}
        sfval_max,#::Vector{Float64}
        sfval_avg,#::Vector{Float64}
        sfval_cov,#::Vector{Float64}
    )

end

"""
    chebyshevparam(nenv, kwargs)

Generate Chebyshev basis parameters for fingerprint calculation.

This internal function processes keyword arguments to set up Chebyshev polynomial
basis functions for both radial and angular symmetry functions.

# Arguments
- `nenv::Int`: Number of environment types
- `kwargs`: Keyword arguments containing Chebyshev parameters

# Required in kwargs
- `radial_Rc`: Radial cutoff radius
- `radial_N`: Number of radial basis functions
- `angular_Rc`: Angular cutoff radius  
- `angular_N`: Number of angular basis functions

# Returns
- `sfparam::Matrix{Float64}`: Parameter matrix for symmetry functions
- `sfenv::Matrix{Int64}`: Environment mapping matrix
- `Rc::Float64`: Maximum cutoff radius
- `num_of_coeffs::Int`: Total number of coefficients
- `num_of_parameters::Int`: Number of parameters per coefficient

# Throws
- `ErrorException`: If any required parameter is missing
"""
function chebyshevparam(nenv, kwargs)
    if haskey(kwargs, :radial_Rc)
        #println("radial_Rc = ", kwargs[:radial_Rc])
    else
        error("radial_Rc is not found in keywords $(kwargs)")
    end
    if haskey(kwargs, :radial_N)
        #println("radial_N = ", kwargs[:radial_N])
    else
        error("radial_N is not found in keywords $(kwargs)")
    end
    if haskey(kwargs, :angular_Rc)
        #println("angular_Rc = ", kwargs[:angular_Rc])
    else
        error("angular_Rc is not found in keywords $(kwargs)")
    end
    if haskey(kwargs, :angular_N)
        #println("angular_N = ", kwargs[:angular_N])
    else
        error("angular_N is not found in keywords $(kwargs)")
    end
    num_of_coeffs = kwargs[:radial_N] + kwargs[:angular_N] + 2
    if nenv > 1
        num_of_coeffs *= 2
    end
    Rc = max(kwargs[:angular_Rc], kwargs[:radial_Rc])
    sfparam = zeros(NUM_MAX_FINGERPRINT_PARAMS, num_of_coeffs)
    sfparam[1, 1] = kwargs[:radial_Rc]
    sfparam[2, 1] = kwargs[:radial_N]
    sfparam[3, 1] = kwargs[:angular_Rc]
    sfparam[4, 1] = kwargs[:angular_N]
    sfenv = zeros(NENV_MAX, num_of_coeffs)
    num_of_parameters = NUM_MAX_FINGERPRINT_PARAMS

    return sfparam, sfenv, Rc, num_of_coeffs, num_of_parameters
end

"""
    FingerPrintParams

A structure for storing parameters of individual fingerprint basis components.

This struct contains information about a specific basis type within a fingerprint,
including its parameters and the range of indices it covers in the full fingerprint vector.

# Fields
- `basistype::String`: Type of basis function ("Chebyshev", "Spline", "LJ")
- `num_kinds::Int64`: Total number of basis kinds in the fingerprint
- `numparams::Int64`: Number of parameters for this specific basis
- `params::Vector{Float64}`: Parameter values for this basis
- `startindex::Int64`: Starting index in the full fingerprint vector
- `endindex::Int64`: Ending index in the full fingerprint vector

# See also
- [`get_singlefingerprints_info`](@ref): Creates params for single basis
- [`get_multifingerprints_info`](@ref): Creates params for multi-basis fingerprints
"""
struct FingerPrintParams
    basistype::String
    num_kinds::Int64
    numparams::Int64
    params::Vector{Float64}
    startindex::Int64
    endindex::Int64
end

"""
    get_singlefingerprints_info(fingerprint::FingerPrint, inputdim)

Extract fingerprint parameters for single basis type fingerprints.

This function creates a parameter structure for fingerprints that use only one
type of basis function (e.g., only Chebyshev polynomials).

# Arguments
- `fingerprint::FingerPrint`: The fingerprint structure
- `inputdim::Int`: Input dimension for the neural network

# Returns
- `Vector{FingerPrintParams}`: Vector containing a single FingerPrintParams element

# Example
```julia
params = get_singlefingerprints_info(fingerprint, 64)
```
"""
function get_singlefingerprints_info(fingerprint::FingerPrint, inputdim)
    fingerprint_parameters_set = Vector{FingerPrintParams}(undef, 1)

    fingerprint_parameters = fingerprint.sfparam[:, 1]
    num_kinds = 1
    startindex = 1
    endindex = length(fingerprint.sfparam[:, 1])
    numparams = inputdim
    fingerprint_parameters_set[1] = FingerPrintParams(
        "any single basis",
        num_kinds,
        numparams,
        fingerprint_parameters,
        startindex,
        endindex,
    )
    return fingerprint_parameters_set
end

"""
    get_multifingerprints_info(fingerprint::FingerPrint)

Extract fingerprint parameters for multi-basis type fingerprints.

This function processes fingerprints that combine multiple basis types
(e.g., Chebyshev + Spline + LJ potentials) and creates parameter structures
for each basis component.

# Arguments
- `fingerprint::FingerPrint`: The fingerprint structure (must be multi-basis type)

# Returns
- `Vector{FingerPrintParams}`: Vector containing parameters for each basis type

# Throws
- `AssertionError`: If fingerprint is not a multi-basis version

# Supported Basis Types
- `1`: Chebyshev polynomials
- `2`: Spline functions  
- `3`: Lennard-Jones (LJ) potentials

# Example
```julia
fingerprint_params = get_multifingerprints_info(multi_basis_fingerprint)
for fp_param in fingerprint_params
    println("Basis: \$(fp_param.basistype), Params: \$(fp_param.numparams)")
end
```
"""
function get_multifingerprints_info(fingerprint::FingerPrint)
    @assert fingerprint.sfparam[1, 1] == 0.0 "This finger print is not a multi version"
    fingerprint_parameters = fingerprint.sfparam[:, 1]
    num_kinds = Int(fingerprint_parameters[2])
    #display(fingerprint.sfparam[:, :])
    fingerprint_parameters_set = Vector{FingerPrintParams}(undef, num_kinds)

    #println(num_kinds)
    startindex = 1
    for ikind = 1:num_kinds
        istart = 3 + (ikind - 1) * (NUM_MAX_FINGERPRINT_PARAMS + 2)
        ibasis = Int(fingerprint_parameters[istart])
        if ibasis == 1
            basistype = "Chebyshev"
        elseif ibasis == 2
            basistype = "Spline"
        elseif ibasis == 3
            basistype = "LJ"
        end

        numparams_i = Int(fingerprint_parameters[istart+1])
        params = fingerprint_parameters[(istart+2):(istart+1+NUM_MAX_FINGERPRINT_PARAMS)]
        endindex = startindex + numparams_i - 1

        fingerprint_parameters_set[ikind] = FingerPrintParams(
            basistype,
            num_kinds,
            numparams_i,
            fingerprint_parameters,
            startindex,
            endindex,
        )
        startindex += numparams_i
    end
    return fingerprint_parameters_set
end
